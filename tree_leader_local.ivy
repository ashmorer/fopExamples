#lang ivy 1.7

type node

# true iff there is an edge between X and Y
relation edge(X:node, Y:node)

# true iff there is a path between X and Y that does not include some nodes
relation path(X:node, Y:node)

# edge is symmetric 
axiom edge(X,Y) -> edge(Y,X)

# true iff the edge between X and Y is directed X -> Y (Y is X's parent)
relation parent(X:node, Y:node)

# true iff path(X, Y) and the direction of all the parent relations is X --> Y (X has Y as an ancestor)
relation ancestor(X:node, Y:node)

# true if X is a leader
relation leader(X:node)

# true if (a) distinct(X, Y, Z) , and (b) Y is on the unique path between X and Z
relation btw(X:node, Y:node, Z:node)

after init
{
    assume ~parent(X,Y);
    assume ~ancestor(X, Y);
    assume ~leader(X);
}

action setLeader(p:node) = {
    if forall Z:node . (edge(p, Z) -> parent(Z, p))
    {
        leader(p) := true;
    }
}

action setParent(n1:node, n2:node) =
{
    assume edge(n1, n2) & n1 ~= n2;
    #if n2 could be n1's parent and has n2 is n1's unambiguous choice for parent.
    if ~parent(n2, n1) & forall X:node. (edge(X,n1) -> (parent(X,n1) | X=n2))
    {
        parent(n1,n2) := true;
    }
}   

action trLoc(p:node, p1:node, p2:node, p3:node) =
{
    call setLeader(p);
    if *
    {
        if *
        {
            call setParent(p,p1);
        }   
        else
        {
            call setParent(p,p2);
        }
    }
    else
    {
        call setParent(p,p3);
    }
}

action trC(p:node,p1:node,p2:node,p3:node, q1:node, q2:node, q3:node) = {
    #local neighbourhood of p
    assume edge(p,p1) & edge(p,p2) & edge(p,p3);
    
    #btw is symmetric
    assume (btw(X,Y,Z) -> btw(Z,Y,X));
    
    #parents are a kind of ancestor
    assume (parent(X,Y) -> ancestor(X,Y));
    
    #connectedness assumption instantiated on p,p1,p2,p3,q1,q2,q3
    #forall x: exists y: x~=y & path(x,y)
    assume ((path(X,p)  &  X~=p) | 
            (path(X,p1) & X~=p1) |  
            (path(X,p2) & X~=p2) | 
            (path(X,p3) & X~=p3) | 
            (path(X,q1) & X~=q1) | 
            (path(X,q2) & X~=q2) | 
            (path(X,q3) & X~=q3));
            
    #all processes y are in neighbourhood of p, or are on p1, p2, or p3 branch of tree.
    assume  (btw(p,p1,Y) | btw(p,p2,Y) | btw(p,p3,Y) | Y=p1 | Y=p2 | Y=p3 | Y = p);
           
    #observing neighbourhood q1,q2,q3 satisfying btw
    assume btw(q1,q2,q3);
    
    
    call trLoc(p,p1,p2,p3);
}

export trC



conjecture [safety] (leader(X) & leader(Y)) -> X=Y

#new helpers
conjecture [oneparent] ancestor(X,Y) -> ~ancestor(Y,X)
conjecture [leadNoFollow] leader(X) -> ~ancestor(X,Y)
conjecture [parentbtw] (btw(X,Y,Z) & ancestor(Y,Z)) -> ancestor(X,Y)
conjecture [parentTrans] (ancestor(X,Y) & ancestor(Y,Z)) -> ~ancestor(Z,X)

